#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
(c) Copyright Yoan BOUZIN

  This file is part of Pérégrination v1.0.

    Pérégrination v2.0 is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Pérégrination v1.0 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Pérégrination v2.0.  If not, see <http://www.gnu.org/licenses/>. 2

For Linux User
Installation des bibliothèque géospatial nécéssaire à Basemap:
https://docs.djangoproject.com/fr/1.10/ref/contrib/gis/install/geolibs/

Installation de Basemap
http://matplotlib.org/basemap/users/installing.html

Dicdacticiel à la base de ce script :
http://www.xavierdupre.fr/app/actuariat_python/helpsphinx/notebooks/seance6_graphes_enonce.html

Tutorial de Basemap pour ouvrir et manipuler les fichier SHAPEFILE


Source des fichier shapefile belgique et france
http://www.gadm.org/country

API KEY GOOGLE :
 AIzaSyANZgWdIaN4IhFVPVAmi74SO1LD8RtYMPk
 AIzaSyCrEM_z7ZFOL_okADEuh67m914dPkhUFU0
"""

##########
# IMPORT #
##########

from mpl_toolkits.basemap import Basemap
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon
from matplotlib.collections import PatchCollection
from matplotlib.patches import PathPatch
from matplotlib import cm
from matplotlib import colors
import matplotlib.patches as mpatches
import os
import csv
from operator import itemgetter
import collections
import re
import base64
import webbrowser

# get the correct encoding
import locale
print_encoding =  locale.getdefaultlocale()[1]


#################
# NON NATIVE PACKAGE #
#################

def install_and_import(package):
    """
    install non-native package using pip
    """
    import importlib
    try:
        importlib.import_module(package)
    except ImportError:
        import pip
        pip.main(['install', package])
    finally:
        if package == "gedcompy":
            globals()[package] = importlib.import_module("gedcom")
        else:
            globals()[package] = importlib.import_module(package)
            
from sys import platform
if platform == "linux" or platform == "linux2":
    
    try:
        import folium
    except ImportError:
        install_and_import('folium')

    try:
        import geopy
    except ImportError:
        install_and_import('geopy')

    try:
        import gedcom
    except ImportError:
        install_and_import('gedcompy')
        
elif platform == "darwin":
    sep = "/"
elif platform == "win32":
    try:
        import folium
    except ImportError:
        install_and_import('folium')

    try:
        import geopy
    except ImportError:
        install_and_import('geopy')

    try:
        import gedcom
    except ImportError:
        install_and_import('gedcompy')

#############
# FONCTIONS #
#############

def import_ascendance(f):
    """
    import the txt file generated by Heredis and return a dictionnary with SOsa-stradonitz key number value
    
    input :
        f (file) : tabluated separated file encoded in iso8859_15
        
    output :
        ascdt (dictionary) :
            - key (integer) : Sosa-Stradonitz number
            - value (10-elements list) :
                0 - Sosa-stradonitz-Number
                1 - First Name
                2 - Date of Birth
                3 - Town of Birth
                4 - Husband/Wife
                5 - Wedding Date
                6 - Wedding City
                7 - Date of Death
                8 - Town of Death
                9 - Age
                
    NOTE : it's important to note than the heredis file are encoded in the iso8859_15 format
    """
    lol = list(csv.reader(open(f, 'r'), delimiter='\t'))
    
    ascdt = dict()
    for i in lol:
        key = i[0]
        key = key.decode('iso8859_15').replace(u'\xa0','').replace(' ','')
        if "(" in key:
            key = int(key.split('(')[0])
        elif "+" in key:
            key = int(key.replace("++",""))
        else:
            key = int(key)
        ascdt[key] = i
    return ascdt
    
def import_town_gps_coord(town_file):
    """
    return dictionary of town with latitude and longitude
    
    input :
        town_file (file) :
            The file generated by Heredis and SQLite Manager. See the documentation to how have the file
            
    output :
        dico_town (dictionary) :
            - key (string) : town_name
            - value (2-element tuple)  : (latitude,longitude)
    """
    lol = csv.reader(open(town_file, 'r'),delimiter=",")
    dico_town = {rows[0]:[float(rows[1]),float(rows[2])] for rows in lol}
    return dico_town

def check_generation(sosa):
    """
    return the number of the generation by the given sosa number
    
    input:
        sosa (integer) : the Sosa-Stradonitz number
        
    output :
        generation (interger) : the corresponding generation of sosa
    """
    i = 0
    generation = None
    while generation == None:
        if sosa < pow(2,i):
            generation = i
        i+=1
    return generation

def convert_to_trajectory_ascdt(ascdt,town_list):
    """
    Convert the dictionnary into a list of trajectory
    
    input :
        ascdt (dictionnary) : the object returned by import_ascendance() function
        town_list (dictionnary) : the object returned by import_town_gps_coord()
        
    output :
        traj : tuple of 7 elements :
            -0 : longitude of the cityA (city of the father/mother)
            -1 : latitude of the cityA (city of the father/mother)
            -2 : longitude of the cityB (city of the sosa)
            -3 : latitude of the cityB (city of the sosa)
            -4 : cityA name
            -5 : cityB name
            -6 : generation of the parents
        coo : tuple of 5 elements contening
            -0 : longitude of the cityA (city of the father/mother)
            -1 : latitude of the cityA (city of the father/mother)
            -2 : longitude of the cityB (city of the sosa)
            -3 : latitude of the ityB (city of the sosa)
            -4 : generation of the parents
    """
    list_traj = list()
    list_coord = list()
    for i in ascdt.keys():
        p = i*2
        m = i*2+1
        for prts in p,m:
            if prts in ascdt.keys():
                g = check_generation(prts)
                cityA = ascdt[prts][3].decode('iso8859_15').encode('utf8')
                cityB = ascdt[i][3].decode('iso8859_15').encode('utf8')
                if cityA != ''  :
                    if cityB != '' :
                        if cityA != cityB:
                            print("sosa numero "+str(i))
                            #print(str(i)+" "+cityA.decode('iso8859_15').encode(print_encoding)+" "+cityB.decode('iso8859_15').encode(print_encoding))
                            traj = (town_list[cityA][0],town_list[cityA][1],
                                    town_list[cityB][0],town_list[cityB][1],
                                    cityA.decode('utf8'), cityB.decode('utf8'),g)
                            coo = (town_list[cityA][0], town_list[cityA][1],
                                   town_list[cityB][0],town_list[cityB][1],g)
                            list_traj += [traj]
                            list_coord += [coo]
    return list(set(list_traj)), list(set(list_coord))

def convert_to_trajectory_ascdt_GEDCOM(ascdt,town_list,dico_ID):
    """
    Convert the dictionnary into a list of trajectory
    Adapted for GEDCOM importation
    
    input :
        ascdt (dictionnary) : the object returned by import_ascendance() function
        town_list (dictionnary) : the object returned by import_town_gps_coord()
        
    output :
        traj : tuple of 7 elements :
            -0 : longitude of the cityA (city of the father/mother)
            -1 : latitude of the cityA (city of the father/mother)
            -2 : longitude of the cityB (city of the sosa)
            -3 : latitude of the cityB (city of the sosa)
            -4 : cityA name
            -5 : cityB name
            -6 : generation of the parents
        coo : tuple of 5 elements contening
            -0 : longitude of the cityA (city of the father/mother)
            -1 : latitude of the cityA (city of the father/mother)
            -2 : longitude of the cityB (city of the sosa)
            -3 : latitude of the ityB (city of the sosa)
            -4 : generation of the parents
    """
    list_traj = list()
    list_coord = list()
    for i in ascdt.keys():
        p = i*2
        m = i*2+1
        for prts in p,m:
            if prts in ascdt.keys():
                g = check_generation(prts)
                cityA = ascdt[prts][3]
                cityB = ascdt[i][3]
                if cityA != ''  :
                    if cityB != '' :
                        if cityA != cityB:
                            print("sosa numero "+str(i)+" "+dico_ID[ascdt[i][0]].decode("iso8859_15"))
                            traj = (town_list[cityA][0],town_list[cityA][1],town_list[cityB][0],town_list[cityB][1],cityA, cityB,g)
                            coo = (town_list[cityA][0], town_list[cityA][1],town_list[cityB][0],town_list[cityB][1],g)
                            list_traj += [traj]
                            list_coord += [coo]
                if cityA == '' and  cityB != '':
                    city = False
                    p_i = prts * 2
                    m_i = prts * 2 + 1 #for the range we add extra 1
                    max_i = max(ascdt.keys())
                    while city == False:
                        #break point to avoid infinite loop
                        liste_prts_ascdt = list()
                        for idx_i in range(p_i,m_i):
                            if idx_i in ascdt.keys():
                                liste_prts_ascdt+=[idx_i]
                        #check point
                        if len(liste_prts_ascdt) == 0:
                            break
                        #analyse
                        else:
                            for prts_i in range(p_i,m_i):
                                if prts_i in ascdt.keys():
                                    g = check_generation(prts_i)
                                    cityA = ascdt[prts_i][3]
                                    if cityA != ''  :
                                        if cityB != '' :
                                            if cityA != cityB:
                                                city = True
                                                print("sosa numero "+str(i)+" "+dico_ID[ascdt[i][0]].decode("iso8859_15"))
                                                traj = (town_list[cityA][0],town_list[cityA][1], town_list[cityB][0],town_list[cityB][1], cityA, cityB,g)
                                                coo = (town_list[cityA][0], town_list[cityA][1], town_list[cityB][0],town_list[cityB][1],g)
                                                list_traj += [traj]
                                                list_coord += [coo]
                            p_i = p_i*2
                            m_i = m_i*2+1
    return list(set(list_traj)), list(set(list_coord))
           
def find_min_max_coordinate(list_coord):
    """
    find the minimum and maximum coordinate to trace the map
    and add a value to have a margin on the map

    input :
        list_coord (list) : the 2nd object returned by convert_to_trajectory_ascdt()

    output :
        - x_min (float) : the minimum longitude
        - y_min (float) : the minimum latitude
        - x_max (float) : the maximum longitude
        - y_max (float) : the maximum latitude
        - g_max (integer) : the maximum number of generation
    """
    array = np.asarray(list_coord)
    minimums = array.min(axis=0)
    y1_min, x1_min, y2_min, x2_min, g_min = minimums
    x_min = min(x1_min, x2_min)
    y_min = min(y1_min, y2_min)
    
    maximums = array.max(axis=0)
    y1_max, x1_max, y2_max, x2_max, g_max = maximums
    x_max = max(x1_max, x2_max)
    y_max = max(y1_max, y2_max)
    #after found the min and max I had an extra value to have a margin in the map
    x_min = x_min-0.5
    y_min = y_min-0.5
    x_max = x_max+0.5
    y_max= y_max+0.5
    g_max = int(g_max)
    return y_min, x_min, y_max, x_max, g_max
     
def carte(y_min, x_min, y_max, x_max):
    """
    Generate the map with Basemap
    y_min = llcrnrlon : longitude of lower left hand corner of the desired map domain (degrees).
    x_min = llcrnrlat : latitude of lower left hand corner of the desired map domain (degrees).
    y_max = urcrnrlon : longitude of upper right hand corner of the desired map domain (degrees).
    x_max = urcrnrlat : latitude of upper right hand corner of the desired map domain (degrees).
    """
    fig, axes = plt.subplots(1, 1, figsize=(9,9))
    m = Basemap(llcrnrlon=x_min,llcrnrlat=y_min, urcrnrlon=x_max,urcrnrlat=y_max,
                resolution='h',projection='cass',lon_0=3.0585800,lat_0=50.6329700,
               ax=axes)
    m.drawcoastlines()
    #looking for all the SHP files in the SHAPEFILE directory
    from sys import platform
    if platform == "linux" or platform == "linux2":
        sep = "/"
    elif platform == "darwin":
        sep = "/"
    elif platform == "win32":
        sep = "\\"
        
    for root, dirs, files in os.walk(os.getcwd()+sep+"SHAPEFILE"):
        for f in files:
            if f.endswith('.shp'):
                name = os.path.splitext(f)[0]
                print('draw limit border of '+name)
                m.readshapefile(root+sep+name, name)
        
    m.fillcontinents(color='lightgrey', lake_color='#AAAAFF')
    print('draw rivers')
    m.drawrivers(color='b')
    #m.bluemarble()
    m.drawparallels(np.arange(-40,61.,2.))
    m.drawmeridians(np.arange(-20.,21.,2.))
    m.drawmapboundary(fill_color='#BBBBFF')
    return fig, m, axes

def define_size(list_traj):
    """
    Set the size of the trajectory line and circular shape of the town
    according to the number of time they appear and the correspondant generation

    input:
        list_traj (list) :

    output :
        dico_all_size (dictionnary) :
    """
    dico_size_bubble = dict()
    dico_size_trajectory = dict()
    dico_all_size = dict()
    for vecteur in list_traj:
        lat1,lon1,lat2,lon2,name1,name2,g = vecteur
        # create dico with set to compute lenght and width
        for name in name1, name2:
            if name not in dico_size_bubble.keys():
                bubble = set()
                bubble.add(g)
                dico_size_bubble[name] = bubble
            else:
                bubble =  dico_size_bubble[name]
                bubble.add(g)
                dico_size_bubble[name] = bubble
        if (name1,name2) not in dico_size_trajectory.keys():
            traj = set()
            traj.add(g)
            dico_size_trajectory[(name1,name2)] = traj
        else:
            traj =  dico_size_trajectory[(name1,name2)]
            traj.add(g)
            dico_size_trajectory[ (name1,name2)] = traj
            
        size1 = len(dico_size_bubble[name1]) *4
        size2 = len(dico_size_bubble[name2]) *4
        width = len(dico_size_trajectory[(name1,name2)]) *3
        dico_all_size[vecteur] = (size1,size2, width)
    return dico_all_size

def find_nth_character(str1, substr, n):
    """
    return the index of the nth querring subtring
    
    input :
        str1 (string) : the string
        substr (string) : the target string
        n (integer) : the nth occurence you looking for
        
    return :
        pos (integer) : index of the substring at the nth position
    """
    pos = -1
    for x in xrange(n):
        pos = str1.find(substr, pos+1)
        if pos == -1:
            return None
    return pos

def multiple_wedding(line):
    """
    Separates information from each marriage in independent group.
    In the case of multiple marriage, Hérédis concatenate the event data
    in the same line and uses a bulleted list. This function gathers data on
    the husband / wife, the date and town wedding.

    input :
        line (list) : the line with the multiple wedding
    output :
        list_of_result (list of 3-elements tuple)
            name, date, town

    Using RegEx :

        - to catch only family name
            ((?:(?:particules) )?[capital_letter special_capital_letter symbol]+\b)

            particules : list of particule are :
                d'|de|des|la|DE|VAN|LE

            capital_letter : all the capital letter of the alphabet
                ABCDEFGHIJKLMNOPQRSTUVWXYZ

            special_capital_letter : special letter for foreign familly names
                ÀÁÂÄÃÅĄĆČĖĘÈÉÊËÌÍÎÏĮŁŃÒÓÔÖÕØÙÚÛÜŲŪŸÝŻŹÑßÇŒÆČŠŽ∂ð
                
            other_symbol : generally used for composed familly names or to show variation
                , . / ( ) -
    
        - to cath only town
            (?!\s)[\w\s-]+(?<!\s)

        - to catch only years
            [0-9]{4}
    """
    list_of_result = list()
    splitted_names  =  line[4].split('\x95')
    splitted_dates  =  line[5].split('\x95')
    splitted_towns  =  line[6].split('\x95')
    data = zip(splitted_names, splitted_dates, splitted_towns)
    for ndt in data:
        n, d, t = ndt
        names_result = " ".join(re.findall(ur"((?:(?:d'|de|des|la|DE|VAN|LE) )?[A-ZÀÁÂÄÃÅĄĆČĖĘÈÉÊËÌÍÎÏĮŁŃÒÓÔÖÕØÙÚÛÜŲŪŸÝŻŹÑßÇŒÆČŠŽ∂ð,.'-\(\)/]+\b)",unicode(n.decode('iso8859-15')),re.UNICODE))
        date_result = "".join(re.findall(r"[0-9]{4}",d))
        if t:
            if t[-1].isspace():
                town_result = t[1:len(t)-1]
            elif t[0].isspace():
                town_result = t[1:]
        else:
            town_result = ''
        #town_result = "".join(re.findall(ur"(?!\s)[\w\s-]+(?<!\s)",unicode(t.decode('iso8859-15')),re.UNICODE)).encode('utf8')
        if names_result == '' and date_result == '' and town_result == '':
            continue
        else:
            #list_of_result += [(names_result.encode('utf8'),date_result.decode('iso8859_15').encode('utf8'),town_result.encode('utf8'))] #avant       
            list_of_result += [(names_result,date_result,town_result)] #test town_result with no encode
    return list_of_result

def codec(strA,strB):
    """
    Find the correct combination of encoding to concatenate two string
    Related to create_annonation_text_gedcom
    input : strA, strB : string to concatenate
    output : concatenation of strA and strB
    """
    try:
        strAB = strA.encode('iso8859_15')+strB
        return strAB
    except:
        try:
            strAB = strA+strB.encode('iso8859_15')
            return strAB
        except:
            try:
                A = strA.decode('iso8859_15') 
                B = strB.decode('iso8859_15')
                strAB = A + B
                return strAB
            except:
                A = strA.encode('iso8859_15') 
                B = strB.encode('iso8859_15')
                strAB = A + B
                return strAB

def create_annotation_text_gedcom(dico_file,dico_town,options,typ):
    """
    extract information of interest to display in the annotate text box
    
    input :
        dico_file : the return of the import_ascendance() or import_descendance() function
        dico_town : the return of the import_town_gps_coord() function
        option : list of option, the keyword are :
            - Nombre de °,x,+' : to show the repartition of Birth (°) Wedding (x) and Death (+) for a town
            - Nombre total d'événement : sum of the precedent event (Birth, Wedding, Death)
            - Départ(s) :
            - Arrivée(s) :
            - Nom(s) : The familly name in the town
            - Dates extrèmes : The oldest and newest date in the town
        typ : integer equal to 1 or 2 :
            - 1 : ascendance
            - 2 : descendance
            
    output :
        dico_annotation (dictionnary) :
            key (string) : city name
            value (3th-element tuple) : text to add for the specified annotation, latitude and longitude
    """
    #Note : "texte en string"+string_du_fichier
    #dict to store the annotation
    dico_annotation = dict()
    #pre-traitment
    f_lol = list()
    dico_file2 = dict()
    for key, value in dico_file.iteritems():
        liste = list()
        for item in value:
            if isinstance(item,list):
                liste.append("\x95 "+" \x95 ".join(item))
            else:
                liste.append(item)
        f_lol+= [liste]
        #transfert des modif dans un nouveau dict
        dico_file2[key]=liste
    #ecrase la variable de l'ancien par le nouveau dict
    dico_file = dico_file2
    f_array = np.asarray(f_lol)
    f_transpose = np.transpose(f_array)

    #search the extreme date
    dico_date_extreme = dict()
    for i in range(len(f_transpose[0])):
        for j in 2,5,7:
            if "\x95" in f_transpose[j+1][i]:
                continue
            else:
                if f_transpose[j+1][i] not in dico_date_extreme.keys():
                    dico_date_extreme[f_transpose[j+1][i]] = re.findall(r'[0-9]{4}',f_transpose[j][i])
                else:
                    dico_date_extreme[f_transpose[j+1][i]] += re.findall(r'[0-9]{4}',f_transpose[j][i])
    for key in dico_date_extreme.keys():
        if dico_date_extreme[key]:
            a,b = sorted(dico_date_extreme[key])[0], sorted(dico_date_extreme[key])[-1]
            dico_date_extreme[key] = a+' - '+b
        
    #count the number of event
    number_of_birth_by_town = collections.Counter(f_transpose[3])
    number_of_wedding_by_town = collections.Counter(f_transpose[6])
    number_of_death_by_town = collections.Counter(f_transpose[8])
    number_total = number_of_birth_by_town+number_of_wedding_by_town+number_of_death_by_town
    #get the departures and arrivals
    dico_departure = dict()
    dico_arrivals = dict()
    dico_familly_name = dict()
    popup_trajectory = dict()

    ####### BEGIN #######
    ##### ASCENDANCE #####
    
    if typ == 1:
        for sosa in dico_file.keys():
            if "\x95" in dico_file[sosa][4]:
                weddings = multiple_wedding_gedcom(dico_file[sosa])
                for wed in weddings:
                    n,d,t = wed
                    #for the name list
                    if n != '' and t != '':
                        if t not in dico_familly_name.keys():
                            name = set()
                            name.add(n)
                            dico_familly_name[t] = name
                        else:
                            name = dico_familly_name[t]
                            name.add(n)
                            dico_familly_name[t] = name
                    if t:
                        #add to the wedding and total event
                        wedding_counter = collections.Counter([t])
                        number_of_wedding_by_town += wedding_counter
                        number_total += wedding_counter
                    if d:
                        if t:
                            if t not in dico_date_extreme.keys():
                                dico_date_extreme[t] = d+' - '+d
                            elif not dico_date_extreme[t]:
                                dico_date_extreme[t] = d+' - '+d
                            else:
                                #verify extrem date
                                d_int = int(d)
                                a = int(dico_date_extreme[t][:4])
                                b = int(dico_date_extreme[t][7:])
                                hyphen_begin = dico_date_extreme[t][:7]
                                hyphen_end = dico_date_extreme[t][4:]
                                if d_int < a:
                                    dico_date_extreme[t] = d+hyphen_end
                                if d_int > b:
                                    dico_date_extreme[t] = hyphen_begin + d

            #get familly name
            #result = re.findall(ur"[A-ZÀÁÂÄÃÅĄĆČĖĘÈÉÊËÌÍÎÏĮŁŃÒÓÔÖÕØÙÚÛÜŲŪŸÝŻŹÑßÇŒÆČŠŽ∂ð ,.'-\(\)/]+$",unicode(dico_file[sosa][1].decode('iso8859-15')),re.UNICODE)
            result = re.findall(ur"((?:(?: d'| de| des| la| DE| VAN| LE) )?[A-ZÀÁÂÄÃÅĄĆČĖĘÈÉÊËÌÍÎÏĮŁŃÒÓÔÖÕØÙÚÛÜŲŪŸÝŻŹÑßÇŒÆČŠŽ∂ð,.'-\(\)/]+\b)",unicode(dico_file[sosa][1].decode('iso8859-15')),re.UNICODE)
            
            if result:
                familly_name = result[0]
            #iterate over (3) birth, (6) wedding and (8) death town and store into a set
            for index in 3,6,8:
                if "\x95" in dico_file[sosa][index]:
                    continue
                if dico_file[sosa][index] not in dico_familly_name.keys():
                        
                    name = set()
                    name.add(familly_name)
                    dico_familly_name[dico_file[sosa][index]] = name
                else:
                    name = dico_familly_name[dico_file[sosa][index]]
                    name.add(familly_name)
                    dico_familly_name[dico_file[sosa][index]] = name
                    
                    
            #compute parents sosa
            p = sosa*2
            m = sosa*2+1
            for prts in p,m:
                if prts in dico_file.keys():
                    g = check_generation(prts)
                    cityA = dico_file[prts][3]
                    cityB = dico_file[sosa][3]
                    if cityA != ''  :
                        if cityB != '' :
                            if cityA != cityB:
                                if cityA not in dico_departure.keys():
                                    a = "Depart :\nSosa "+str(prts)+" "+dico_file[prts][1]+"\n"
                                    dico_departure[cityA] = a
                                else:
                                    a = "Sosa "+str(prts)+" "+dico_file[prts][1]+"\n"
                                    dico_departure[cityA] = dico_departure[cityA] + a
                                if cityB not in dico_arrivals.keys():
                                    a = "Arrive :\nSosa "+str(prts)+" "+dico_file[prts][1]+"\n"
                                    dico_arrivals[cityB] = a
                                else:
                                    a = "Sosa "+str(prts)+" "+dico_file[prts][1]+"\n"
                                    dico_arrivals[cityB] = dico_arrivals[cityB] + a
                                popup_traj = "Sosa "+str(prts)+" "+dico_file[prts][1]
                                #create a popup for the trajectory
                                if (cityA,cityB) in popup_trajectory.keys():
                                    popup_trajectory[(cityA,cityB)] += " "+popup_traj
                                else:
                                    popup_trajectory[(cityA,cityB)] = popup_traj
                if cityA == '' and  cityB != '':
                    city = False
                    p_i = prts * 2
                    m_i = prts * 2 + 1 #for the range we add extra 1
                    max_i = max(dico_file.keys())
                    while city == False:
                        #break point to avoid infinite loop
                        liste_prts_ascdt = list()
                        for idx_i in range(p_i,m_i):
                            if idx_i in dico_file.keys():
                                liste_prts_ascdt+=[idx_i]
                        #check point
                        if len(liste_prts_ascdt) == 0:
                            break
                        #analyse
                        else:
                            for prts_i in range(p_i,m_i):
                                if prts_i in dico_file.keys():
                                    g = check_generation(prts_i)
                                    cityA = dico_file[prts_i][3]
                                    if cityA != ''  :
                                        if cityB != '' :
                                            if cityA != cityB:
                                                city = True
                                                popup_traj = "Sosa "+str(prts)+" "+dico_file[prts_i][1]
                                                #create a popup for the trajectory
                                                if (cityA,cityB) in popup_trajectory.keys():
                                                    popup_trajectory[(cityA,cityB)] += " "+popup_traj
                                                else:
                                                    popup_trajectory[(cityA,cityB)] = popup_traj
                            p_i = p_i*2
                            m_i = m_i*2+1
    ##### DESCENDANCE #####
    
    if typ ==2:
        # set to avoid the repetion of the same father in all childrens
        set_dep = set()
        set_arr = set()
        for sosa in dico_file.keys():
            if "\x95" in dico_file[sosa][4]:
                weddings = multiple_wedding_gedcom(dico_file[sosa])
                for wed in weddings:
                    n,d,t = wed
                    #for the name list
                    if n != '' and t != '':
                        if t not in dico_familly_name.keys():
                            name = set()
                            name.add(n)
                            dico_familly_name[t] = name
                        else:
                            name = dico_familly_name[t]
                            name.add(n)
                            dico_familly_name[t] = name
                    if t:
                        #add to the wedding and total event
                        wedding_counter = collections.Counter([t])
                        number_of_wedding_by_town += wedding_counter
                        number_total += wedding_counter
                    if d:
                        if d not in dico_date_extreme.keys():
                            dico_date_extreme[t] = d+' - '+d
                        else:
                            #verify extrem date
                            d_int = int(d)
                            a = int(dico_date_extreme[t][:4])
                            b = int(dico_date_extreme[t][7:])
                            hyphen_begin = dico_date_extreme[t][:7]
                            hyphen_end = dico_date_extreme[t][4:]
                            if d_int < a:
                                dico_date_extreme[t] = d+hyphen_end
                            if d_int > b:
                                dico_date_extreme[t] = hyphen_begin + d
            if sosa == '':
                #because the first line of the descendance in PELISSIER contain nothing, we according about the familly name for the order X & Y
                sexe = False
            else:
                sexe = sosa[-1].islower()
            fn = list()
            for i in 1,4:
                #string
                result = re.findall(r"[A-ZÀÁÂÄÃÅĄĆČĖĘÈÉÊËÌÍÎÏĮŁŃÒÓÔÖÕØÙÚÛÜŲŪŸÝŻŹÑßÇŒÆČŠŽ∂ð ,.'-\(\)/]+$",dico_file[sosa][i])
                if result:
                    fn += [result[0].replace(' ','',1)]
            if sexe:
                familly_name = ' & '.join(list(reversed(fn)))
            else:
                familly_name = ' & '.join(fn)
            #iterate over birth, wedding and death town and store into set
            for index in 3,6,8:
                if "\x95" in dico_file[sosa][index]:
                    continue
                if dico_file[sosa][index] not in dico_familly_name.keys():
                    name = set()
                    name.add(familly_name)
                    dico_familly_name[dico_file[sosa][index]] = name
                else:
                    name = dico_familly_name[dico_file[sosa][index]]
                    name.add(familly_name)
                    dico_familly_name[dico_file[sosa][index]] = name

            prts = find_up(sosa)
            if prts in dico_file.keys():
                gen = ''.join([j for j in prts if not j.isdigit()])
                #the lenght of the string +1 equal to the number of the descendent generation
                g = len(gen)+1
                cityA = dico_file[prts][3]
                cityB = dico_file[sosa][3]
                if cityA != ''  :
                    if cityB != '' :
                        if cityA != cityB:
                            if cityA not in dico_departure.keys():
                                a = "Depart :\nn "+str(prts)+" "+dico_file[prts][1]+"\n"
                                dico_departure[cityA] = a
                                set_dep.add(str(prts))
                            else:
                                if prts not in set_dep:
                                    a = "n "+str(prts)+" "+dico_file[prts][1]+"\n"
                                    dico_departure[cityA] = dico_departure[cityA] + a
                                    set_dep.add(str(prts))
                            if cityB not in dico_arrivals.keys():
                                a = "Arrive :\nn°"+str(prts)+" "+dico_file[prts][1]+"\n"
                                dico_arrivals[cityB] = a
                                set_arr.add(str(prts))
                            else:
                                if prts not in set_arr:
                                    a = "n "+str(prts)+" "+dico_file[prts][1]+"\n"
                                    dico_arrivals[cityB] = dico_arrivals[cityB] + a
                                    set_arr.add(str(prts))
                                    
    ##### END #####
                                    
    #transfert all town key (from multiple wedding (utf8) and ascdt / descdt (iso8859_15) file)
    for town in number_total.keys():
        if town != '' and "\x95" not in town:
            dico_annotation[town] = ''
    print('dico annotation keys')
    for town in dico_annotation.keys():
        text = str()
        ### CHECK THE OPTIONS ###
        if "Nombre de °,x,+" in options:
            b = number_of_birth_by_town[town]
            #descendance : don't divide by 2
            if typ == 1:
                w = number_of_wedding_by_town[town]/2
            if typ == 2:
                w = number_of_wedding_by_town[town]
            d = number_of_death_by_town[town]
            a = "Naissance(s) : "+str(b)+"\nMariage(s) : "+str(w)+"\nDeces : "+str(d)+"\n"
            text = codec(text,a)
            #text += a
        if "Nombre total d'événement" in options:
            a = "Nombre total d'evenement : "+str(number_total[town])+"\n"
            #text += a
            text = codec(text,a)
        
        if 'Départ(s)' in options:
            if town in dico_departure.keys():
                #text += dico_departure[town]+"\n"
                text = codec(text,dico_departure[town]+"\n")
        if 'Arrivée(s)' in options:
            if town in dico_arrivals.keys():
                #text += dico_arrivals[town]+"\n"
                text = codec(text, dico_arrivals[town]+"\n")
        if 'Nom(s)' in options:
            if town in dico_familly_name.keys():
                n = ", ".join([i if isinstance(i, unicode) else unicode(i.decode('iso8859_15')) for i in dico_familly_name[town]])
                for i in range(4,n.count(', '),3):
                    idx = find_nth_character(n, ', ', i)
                    if idx:
                        n = n[:find_nth_character(n, ', ', i)] + "\n" + n[2+find_nth_character(n, ', ', i):]
                #n2 ="Noms :\n".encode('iso8859_15')+n
                n2 = codec("Noms :\n", n)
                text = codec(text, n2)
                #text += n2
        if 'Dates extrêmes' in options:
            if town in dico_date_extreme.keys():
                if dico_date_extreme[town]:
                    #date = '\nDate : '.encode('iso8859_15')+dico_date_extreme[town]
                    date = codec('\nDate : ',dico_date_extreme[town])
                    #text += date
                    text = codec(text, date)
        try:
            lat = dico_town[town][0]
            lon = dico_town[town][1]
            dico_annotation[town] = (text,lat,lon)
        except KeyError:
            lat = dico_town[town][0]
            lon = dico_town[town][1]
            dico_annotation[town] = (text,lat,lon)
    return dico_annotation, popup_trajectory

def multiple_wedding_gedcom(line):
    """
    Separates information from each marriage in independent group.
    In the case of multiple marriage, Hérédis concatenate the event data
    in the same line and uses a bulleted list. This function gathers data on
    the husband / wife, the date and town wedding.

    input :
        line (list) : the line with the multiple wedding
    output :
        list_of_result (list of 3-elements tuple)
            name, date, town

    Using RegEx :

        - to catch only family name
            ((?:(?:particules) )?[capital_letter special_capital_letter symbol]+\b)

            particules : list of particule are :
                d'|de|des|la|DE|VAN|LE

            capital_letter : all the capital letter of the alphabet
                ABCDEFGHIJKLMNOPQRSTUVWXYZ

            special_capital_letter : special letter for foreign familly names
                ÀÁÂÄÃÅĄĆČĖĘÈÉÊËÌÍÎÏĮŁŃÒÓÔÖÕØÙÚÛÜŲŪŸÝŻŹÑßÇŒÆČŠŽ∂ð
                
            other_symbol : generally used for composed familly names or to show variation
                , . / ( ) -
    
        - to cath only town
            (?!\s)[\w\s-]+(?<!\s)

        - to catch only years
            [0-9]{4}
    """
    list_of_result = list()
    splitted_names  =  line[4].split('\x95')
    splitted_dates  =  line[5].split('\x95')
    splitted_towns  =  line[6].split('\x95')
    data = zip(splitted_names, splitted_dates, splitted_towns)
    for ndt in data:
        n, d, t = ndt
        names_result = " ".join(re.findall(ur"((?:(?:d'|de|des|la|DE|VAN|LE) )?[A-ZÀÁÂÄÃÅĄĆČĖĘÈÉÊËÌÍÎÏĮŁŃÒÓÔÖÕØÙÚÛÜŲŪŸÝŻŹÑßÇŒÆČŠŽ∂ð,.'-\(\)/]+\b)",unicode(n.decode('iso8859-15')),re.UNICODE))
        date_result = "".join(re.findall(r"[0-9]{4}",d))
        if t:
            if t[-1].isspace():
                town_result = t[1:len(t)-1]
            elif t[0].isspace():
                town_result = t[1:]
        else:
            town_result = ''
        #town_result = "".join(re.findall(ur"(?!\s)[\w\s-]+(?<!\s)",unicode(t.decode('iso8859-15')),re.UNICODE))
        if names_result == '' and date_result == '' and town_result == '':
            continue
        else:
            #list_of_result += [(names_result,date_result,town_result)] #avant       
            list_of_result += [(names_result,date_result,town_result)] #test town_result with no encode
    return list_of_result

def create_annotation_text(dico_file,dico_town,options,typ):
    """
    extract information of interest to display in the annotate text box
    
    input :
        dico_file : the return of the import_ascendance() or import_descendance() function
        dico_town : the return of the import_town_gps_coord() function
        option : list of option, the keyword are :
            - Nombre de °,x,+' : to show the repartition of Birth (°) Wedding (x) and Death (+) for a town
            - Nombre total d'événement : sum of the precedent event (Birth, Wedding, Death)
            - Départ(s) :
            - Arrivée(s) :
            - Nom(s) : The familly name in the town
            - Dates extrèmes : The oldest and newest date in the town
        typ : integer equal to 1 or 2 :
            - 1 : ascendance
            - 2 : descendance
            
    output :
        dico_annotation (dictionnary) :
            key (string) : city name
            value (3th-element tuple) : text to add for the specified annotation, latitude and longitude
    """
    #Note : "texte en string".decode('utf8')+string_du_fichier.decode('iso8859_15')
    #dict to store the annotation
    dico_annotation = dict()
    #pre-traitment
    f_lol = list()
    for key, value in dico_file.iteritems():
        f_lol.append(value)
    
    f_array = np.asarray(f_lol)
    f_transpose = np.transpose(f_array)

    #search the extreme date
    dico_date_extreme = dict()
    for i in range(len(f_transpose[0])):
        for j in 2,5,7:
            if "\x95" in f_transpose[j+1][i]:
                continue
            else:
                if f_transpose[j+1][i] not in dico_date_extreme.keys():
                    dico_date_extreme[f_transpose[j+1][i]] = re.findall(r'[0-9]{4}',f_transpose[j][i])
                else:
                    dico_date_extreme[f_transpose[j+1][i]] += re.findall(r'[0-9]{4}',f_transpose[j][i])
    for key in dico_date_extreme.keys():
        if dico_date_extreme[key]:
            a,b = sorted(dico_date_extreme[key])[0], sorted(dico_date_extreme[key])[-1]
            dico_date_extreme[key] = a.decode('iso8859_15')+' - '.decode('utf8')+b.decode('iso8859_15')
        
    #count the number of event
    number_of_birth_by_town = collections.Counter(f_transpose[3])
    number_of_wedding_by_town = collections.Counter(f_transpose[6])
    number_of_death_by_town = collections.Counter(f_transpose[8])
    number_total = number_of_birth_by_town+number_of_wedding_by_town+number_of_death_by_town
    #get the departures and arrivals
    dico_departure = dict()
    dico_arrivals = dict()
    dico_familly_name = dict()

    ####### BEGIN #######
    ##### ASCENDANCE #####
    
    if typ == 1:
        for sosa in dico_file.keys():
            if "\x95" in dico_file[sosa][4]:
                weddings = multiple_wedding(dico_file[sosa])
                for wed in weddings:
                    n,d,t = wed
                    #for the name list
                    if n != '' and t != '':
                        if t not in dico_familly_name.keys():
                            name = set()
                            name.add(n)
                            dico_familly_name[t] = name
                        else:
                            name = dico_familly_name[t]
                            name.add(n)
                            dico_familly_name[t] = name
                    if t:
                        #add to the wedding and total event
                        wedding_counter = collections.Counter([t])
                        number_of_wedding_by_town += wedding_counter
                        number_total += wedding_counter
                    if d:
                        if d not in dico_date_extreme.keys():
                            dico_date_extreme[t] = d+' - '+d
                        else:
                            #verify extrem date
                            d_int = int(d)
                            a = int(dico_date_extreme[t][:4])
                            b = int(dico_date_extreme[t][7:])
                            hyphen_begin = dico_date_extreme[t][:7]
                            hyphen_end = dico_date_extreme[t][4:]
                            if d_int < a:
                                dico_date_extreme[t] = d+hyphen_end
                            if d_int > b:
                                dico_date_extreme[t] = hyphen_begin + d

            #get familly name
            result = re.findall(r"[A-ZÀÁÂÄÃÅĄĆČĖĘÈÉÊËÌÍÎÏĮŁŃÒÓÔÖÕØÙÚÛÜŲŪŸÝŻŹÑßÇŒÆČŠŽ∂ð ,.'-\(\)/]+$",dico_file[sosa][1].decode('iso8859_15').encode('utf8'))
            if result:
                familly_name = result[0]
            #iterate over (3) birth, (6) wedding and (8) death town and store into a set
            for index in 3,6,8:
                if "\x95" in dico_file[sosa][index]:
                    continue
                if dico_file[sosa][index] not in dico_familly_name.keys():
                        
                    name = set()
                    name.add(familly_name)
                    dico_familly_name[dico_file[sosa][index]] = name
                else:
                    name = dico_familly_name[dico_file[sosa][index]]
                    name.add(familly_name)
                    dico_familly_name[dico_file[sosa][index]] = name
                    
                    
            #compute parents sosa
            p = sosa*2
            m = sosa*2+1
            for prts in p,m:
                if prts in dico_file.keys():
                    g = check_generation(prts)
                    cityA = dico_file[prts][3]
                    cityB = dico_file[sosa][3]
                    if cityA != ''  :
                        if cityB != '' :
                            if cityA != cityB:
                                if cityA not in dico_departure.keys():
                                    a = "Départ :\nSosa n°".decode('utf8')+str(prts)+" "+dico_file[prts][1].decode('iso8859_15')+"\n"
                                    dico_departure[cityA] = a
                                else:
                                    a = "Sosa n°".decode('utf8')+str(prts)+" "+dico_file[prts][1].decode('iso8859_15')+"\n"
                                    dico_departure[cityA] = dico_departure[cityA] + a
                                if cityB not in dico_arrivals.keys():
                                    a = "Arrivé :\nSosa n°".decode('utf8')+str(prts)+" "+dico_file[prts][1].decode('iso8859_15')+"\n"
                                    dico_arrivals[cityB] = a
                                else:
                                    a = "Sosa n°".decode('utf8')+str(prts)+" "+dico_file[prts][1].decode('iso8859_15')+"\n"
                                    dico_arrivals[cityB] = dico_arrivals[cityB] + a

    ##### DESCENDANCE #####
    
    if typ ==2:
        # set to avoid the repetion of the same father in all childrens
        set_dep = set()
        set_arr = set()
        for sosa in dico_file.keys():
            if "\x95" in dico_file[sosa][4]:
                weddings = multiple_wedding(dico_file[sosa])
                for wed in weddings:
                    n,d,t = wed
                    #for the name list
                    if n != '' and t != '':
                        if t not in dico_familly_name.keys():
                            name = set()
                            name.add(n)
                            dico_familly_name[t] = name
                        else:
                            name = dico_familly_name[t]
                            name.add(n)
                            dico_familly_name[t] = name
                    if t:
                        #add to the wedding and total event
                        wedding_counter = collections.Counter([t])
                        number_of_wedding_by_town += wedding_counter
                        number_total += wedding_counter
                    if d:
                        if d not in dico_date_extreme.keys():
                            dico_date_extreme[t] = d+' - '+d
                        else:
                            #verify extrem date
                            d_int = int(d)
                            a = int(dico_date_extreme[t][:4])
                            b = int(dico_date_extreme[t][7:])
                            hyphen_begin = dico_date_extreme[t][:7]
                            hyphen_end = dico_date_extreme[t][4:]
                            if d_int < a:
                                dico_date_extreme[t] = d+hyphen_end
                            if d_int > b:
                                dico_date_extreme[t] = hyphen_begin + d
            if sosa == '':
                #because the first line of the descendance in PELISSIER contain nothing, we according about the familly name for the order X & Y
                sexe = False
            else:
                sexe = sosa[-1].islower()
            fn = list()
            for i in 1,4:
                #string
                result = re.findall(r"[A-ZÀÁÂÄÃÅĄĆČĖĘÈÉÊËÌÍÎÏĮŁŃÒÓÔÖÕØÙÚÛÜŲŪŸÝŻŹÑßÇŒÆČŠŽ∂ð ,.'-\(\)/]+$",dico_file[sosa][i].decode('iso8859_15').encode('utf8'))
                if result:
                    fn += [result[0].replace(' ','',1)]
            if sexe:
                familly_name = ' & '.encode('utf8').join(list(reversed(fn)))
            else:
                familly_name = ' & '.encode('utf8').join(fn)
            #iterate over birth, wedding and death town and store into set
            for index in 3,6,8:
                if "\x95" in dico_file[sosa][index]:
                    continue
                if dico_file[sosa][index] not in dico_familly_name.keys():
                    name = set()
                    name.add(familly_name)
                    dico_familly_name[dico_file[sosa][index]] = name
                else:
                    name = dico_familly_name[dico_file[sosa][index]]
                    name.add(familly_name)
                    dico_familly_name[dico_file[sosa][index]] = name

            prts = find_up(sosa)
            if prts in dico_file.keys():
                gen = ''.join([j for j in prts if not j.isdigit()])
                #the lenght of the string +1 equal to the number of the descendent generation
                g = len(gen)+1
                cityA = dico_file[prts][3]
                cityB = dico_file[sosa][3]
                if cityA != ''  :
                    if cityB != '' :
                        if cityA != cityB:
                            if cityA not in dico_departure.keys():
                                a = "Départ :\nn°".decode('utf8')+str(prts)+" "+dico_file[prts][1].decode('iso8859_15')+"\n"
                                dico_departure[cityA] = a
                                set_dep.add(str(prts))
                            else:
                                if prts not in set_dep:
                                    a = "n°".decode('utf8')+str(prts)+" "+dico_file[prts][1].decode('iso8859_15')+"\n"
                                    dico_departure[cityA] = dico_departure[cityA] + a
                                    set_dep.add(str(prts))
                            if cityB not in dico_arrivals.keys():
                                a = "Arrivé :\nn°".decode('utf8')+str(prts)+" "+dico_file[prts][1].decode('iso8859_15')+"\n"
                                dico_arrivals[cityB] = a
                                set_arr.add(str(prts))
                            else:
                                if prts not in set_arr:
                                    a = "n°".decode('utf8')+str(prts)+" "+dico_file[prts][1].decode('iso8859_15')+"\n"
                                    dico_arrivals[cityB] = dico_arrivals[cityB] + a
                                    set_arr.add(str(prts))
                                    
    ##### END #####
                                    
    #transfert all town key (from multiple wedding (utf8) and ascdt / descdt (iso8859_15) file)
    for town in number_total.keys():
        if town != '' and "\x95" not in town:
            dico_annotation[town] = ''
    for town in dico_annotation.keys():
        text = str()
        if "Nombre de °,x,+" in options:
            b = number_of_birth_by_town[town]
            #descendance : don't divide by 2
            if typ == 1:
                w = number_of_wedding_by_town[town]/2
            if typ == 2:
                w = number_of_wedding_by_town[town]
            d = number_of_death_by_town[town]
            a = "Naissance(s) : ".decode('utf8')+str(b)+"\nMariage(s) : ".decode('utf8')+str(w)+"\nDécès : ".decode('utf8')+str(d)+"\n"
            text += a
        if "Nombre total d'événement" in options:
            a = "Nombre total d'événement : ".decode('utf8')+str(number_total[town])+"\n"
            text += a
        
        if 'Départ(s)' in options:
            if town in dico_departure.keys():
                text += dico_departure[town]+"\n"
        if 'Arrivée(s)' in options:
            if town in dico_arrivals.keys():
                text += dico_arrivals[town]+"\n"
        if 'Nom(s)' in options:
            if town in dico_familly_name.keys():
                n = ", ".join(dico_familly_name[town])
                for i in range(4,n.count(', '),3):
                    idx = find_nth_character(n, ', ', i)
                    if idx:
                        n = n[:find_nth_character(n, ', ', i)] + "\n" + n[2+find_nth_character(n, ', ', i):]
                n2 ="Noms :\n".decode('utf8')+n.decode('iso8859_15')
                text += n2
        if 'Dates extrêmes' in options:
            if town in dico_date_extreme.keys():
                date = '\nDate : '.decode('utf8')+dico_date_extreme[town]
                text += date
        try:
            lat = dico_town[town][0]
            lon = dico_town[town][1]
            dico_annotation[town] = (text,lat,lon)
        except KeyError:
            lat = dico_town[town.decode('iso8859_15').encode('utf8')][0]
            lon = dico_town[town.decode('iso8859_15').encode('utf8')][1]
            dico_annotation[town] = (text,lat,lon)
    return dico_annotation

def mapping_trajectory(list_traj,m,ax,g_max,typ,dico_annotation):
    """
    Draw the trajectory to the Basemap using greatcircle and the associated legend
    to avoid the cover of the last generation to the first,we sort the list in reverse order by the number of generation
    
    input :
        list_traj (list) : object list returned by convert_to_trajectory_ascdt() / convert_to_trajectory_descdt() function
        m (matplotlib Basemap object) : second object returned by carte() function
        ax (matplotlib axis object) : third object returned by carte() function
        g_max (integer) : the maximum generation
        typ (integer) : integer equal to 1 or 2 :
            - 1 : ascendance
            - 2 : descendance
        dico_annotation (dictionnary) : dictionnary returned by create_annotation_text()
        
    output :
        points_with_annotation (liste of liste):
            sub-list (list) : contain pair of point and annotation
                -point (matplotlib object) : the city
                -annotation (matplotlib object) : the annotation of the point
        
    """
    #compute in the first time the size of the lines and shapes
    
    print("compute sizes")
    if typ == 1:
        list_traj = sorted(list_traj, key=itemgetter(6), reverse=False)
        dico_all_size = define_size(list_traj)
        #reverse mode important to avoid the cover of the smallest circular shapes
        list_traj = sorted(list_traj, key=itemgetter(6), reverse=True)
    elif typ == 2:
        list_traj = sorted(list_traj, key=itemgetter(6), reverse=True)
        dico_all_size = define_size(list_traj)
        #reverse mode important to avoid the cover of the smallest circular shapes
        list_traj = sorted(list_traj, key=itemgetter(6), reverse=False)
        
    print("draw trajectory")
    set_town = set()
    list_text_point = list()
    for vecteur in list_traj:
        size1, size2, width = dico_all_size[vecteur]
        lat1,lon1,lat2,lon2,name1,name2,g = vecteur

        if name1 == name2:
            #only for descendant file
            if typ == 2:
                x1,y1 = m(lon1, lat1)
                point, = m.plot(x1, y1, 'o', markersize=size1,markeredgewidth=0.0,color=cm.Paired(1.*g/g_max))
                # to avoid superposition of text in same location
                if name1 not in set_town:
                    text_point_desc = ax.text(x1, y1, name1)
                    set_town.add(name1)
                    list_text_point.append(text_point_desc)
            
        #for the other case
        else:
            
            x1,y1 = m(lon1, lat1)
            point1, = m.plot(x1, y1, 'o', markersize=size1,markeredgewidth=0.0,color=cm.Paired(1.*g/g_max))

            if name1 not in set_town:
                text_point1 = ax.text(x1, y1, name1)
                set_town.add(name1)
                list_text_point.append(text_point1)
                            
            x2,y2 = m(lon2, lat2)
            point2, = m.plot(x2, y2, 'o', markersize=size2,markeredgewidth=0.0,color=cm.Paired(1.*g/g_max))
            m.drawgreatcircle(lon1,lat1,lon2,lat2,linewidth=width,color=cm.Paired(1.*g/g_max))
            # to avoid superposition of text in same location
            if name2 not in set_town:
                text_point2 = ax.text(x2, y2, name2)
                set_town.add(name2)
                list_text_point.append(text_point2)
                
    print("draw annotation")
    points_with_annotation = []
    for town in dico_annotation.keys():
        if dico_annotation[town]:
            ann, lat, lon = dico_annotation[town]
            x,y = m(lon, lat)
            point, = m.plot(x, y, alpha=0)
            if town.decode('iso8859_15') not in set_town:
                point, = m.plot(x, y, 'ok',alpha=1)
                text_point_other = ax.text(x, y, town.decode('iso8859_15'))
                set_town.add(town.decode('iso8859_15'))
                list_text_point.append(text_point_other)
            annotation = ax.annotate(ann,
                xy=(x, y), xycoords='data',
                xytext=(x, y), textcoords='data',
                horizontalalignment="left",
                arrowprops=dict(facecolor='blue',
                                arrowstyle="-|>",
                                connectionstyle="arc3,rad=-0.2"),
                bbox=dict(boxstyle="round", facecolor="w", 
                          edgecolor="0.5", alpha= 0.95))
            annotation.set_visible(False)
            points_with_annotation.append([point, annotation])                
    print("legend")
    #plot legend
    patch_list = list()
    for i in range(1,g_max+1):
        patch_list.append(mpatches.Patch(color=cm.Paired(1.*i/g_max), label='Gen. '.decode('utf8')+str(i)))
    plt.legend(handles=patch_list, loc='upper center', bbox_to_anchor=(0.5, 0.0),fancybox=True, shadow=True, ncol=5)
    
    return points_with_annotation, list_text_point

def import_descendance(f):
    """
    import the descendance txt file generated by Heredis and return a dictionnary with Sosa-stradonitz key number value
    The descendance are in PELISSIER format
    
    input :
        f (file) : 
    output:
        descdt (dictionary) :
            - key (string) : Sosa-Stradonitz number
            - value (10-elements list) :
                0 - PELISSIER-Number
                1 - First Name
                2 - Date of Birth
                3 - Town of Birth
                4 - Husband/Wife
                5 - Wedding Date
                6 - Wedding City
                7 - Date of Death
                8 - Town of Death
                9 - Age
                
    NOTE :
        - it's important to note than the heredis file are encoded in the iso8859_15 format
        - Contrary to the import_ascendance function, we don't need to convert the Pelissier ID in integer
    """
    lol = list(csv.reader(open(f, 'r'), delimiter='\t'))
    descdt = dict()
    descdt = {rows[0]:rows for rows in lol}
    return descdt

def find_up(key):
    """
    Get the Pelissier parent ID of a given Pelissier ID
    input :
        key (string) : the Pelissier ID
    output :
        up (string) : the parent Pelisier ID of the given ID
    """
    if len(key) == 1:
        return ''
    #to have the departure point of the foundator of the branch
    elif key == '':
        return ''
    elif "." in key:
        up = ".".join(key.split(".")[:-1])
        return up
    else:
        if key[-2].isdigit():
            up = key[:-2]
        else:
            up = key[:-1]
        return up

def convert_to_trajectory_descdt(descdt,town_list):
    """
    convert the dictionnary into a list of trajectory
    input :
        descdt (dictionnary) : the object returned by import_descendance() function
        town_list (dictionnary) : the object returned by import_town_gps_coord()
    output :
        traj (tuple of 7-elements) :
            -0 : longitude of the cityA (city of the father/mother)
            -1 : latitude of the cityA (city of the father/mother)
            -2 : longitude of the cityB (city of the sosa)
            -3 : latitude of the ityB (city of the sosa)
            -4 : cityA name
            -5 : cityB name
            -6 : generation of the parents
        coo (tuple of 5-elements) :
            -0 : longitude of the cityA (city of the father/mother)
            -1 : latitude of the cityA (city of the father/mother)
            -2 : longitude of the cityB (city of the sosa)
            -3 : latitude of the ityB (city of the sosa)
            -4 : generation of the parents
    """
    list_traj = list()
    list_coord = list()
    for i in descdt.keys():
        prts = find_up(i)
        if prts in descdt.keys():
            #trouvé un moyen de trouvé la generation descendante
            gen = ''.join([j for j in prts if not j.isdigit()])
            #the lenght of the string +1 equal to the number of the descendent generation
            g = len(gen)+1
            cityA = descdt[prts][3].decode('iso8859_15').encode('utf8').replace('?','')
            cityB = descdt[i][3].decode('iso8859_15').encode('utf8').replace('?','')
            if cityA != ''  :
                if cityB != '' :
                    print("individue numero "+i)
                    #print(i+" "+cityA.decode('iso8859_15')+" "+cityB.decode('iso8859_15'))
                    traj = (town_list[cityA][0],town_list[cityA][1],
                            town_list[cityB][0],town_list[cityB][1],
                            cityA.decode('utf8'), cityB.decode('utf8'),g)
                    coo = (town_list[cityA][0], town_list[cityA][1],
                           town_list[cityB][0],town_list[cityB][1],g)
                    list_traj += [traj]
                    list_coord += [coo]
    return list(set(list_traj)), list(set(list_coord))

def generate_map_gedcom(typ,y_min, x_min, y_max, x_max,g_max,list_traj,dico_annotation, popup_trajectory, filename, shapefile):
    """
    Generate Open Street Map HTML page
    """
    xmean = np.mean([x_min,x_max])
    ymean = np.mean([y_min,y_max])
    if typ == 1:
        list_traj = sorted(list_traj, key=itemgetter(6), reverse=True)
    elif typ == 2:
        list_traj = sorted(list_traj, key=itemgetter(6), reverse=True)
    my_map1 = folium.Map(location=[ymean,xmean],tiles='Stamen Terrain',zoom_start=6)
    my_map2 = folium.Map(location=[ymean,xmean],zoom_start=6)
    for my_map in my_map1, my_map2:
        town_set = set()
        dico_traj_size = dict()
        #create step color map
        hexa_colors = list()
        for g in range(1, g_max+1):
            cm_object = cm.Paired(1.*g/g_max)
            rgb = cm_object[:3]
            hexa = colors.rgb2hex(rgb)
            hexa_colors.append(hexa)
        #make legend
        #colormap = folium.colormap.linear.Paired.scale(1, g_max).to_step(g_max)
        colormap = folium.colormap.StepColormap(hexa_colors, index=None, vmin=1.0, vmax=float(g_max), caption= u"Générations")
        my_map.add_child(colormap)
        #make shapefile (only if its in group mode)
        if shapefile:
            my_map.choropleth(geo_path='data_tmp.json',fill_color='red')
        nb_polyline = dict()
        #dico to store the town description and avoid overlap of marker when
        dico_pop = dict()
        dico_size = dict()
        for data in list_traj:
            y1,x1,y2,x2,m1,m2,g= data
            
            #polyline
            if ((y1,x1),(y2,x2)) not in nb_polyline.keys():
                nb_polyline[(y1,x1),(y2,x2)] = 1
            else:
                nb_polyline[(y1,x1),(y2,x2)] += 1
                
            for y, x, m, g in (y1,x1,m1,g),(y2,x2,m2,g):
                try:
                    pop = m.decode('iso8859_15')+"\n"+dico_annotation[m][0].decode('iso8859_15')
                except UnicodeEncodeError:
                    pop = m.decode('iso8859_15')+"\n"+dico_annotation[m][0]
                if (y,x) not in dico_pop.keys():
                    pop_ad = set()
                    pop_ad.add(pop)
                    dico_pop[(y,x)] = pop_ad
                else:
                    pop_ad = dico_pop[(y,x)]
                    pop_ad.add(pop)
                    dico_pop[(y,x)] = pop_ad
                #generation polyline marker size
                if (y,x) not in dico_size.keys():
                    dico_size[(y,x)]=[g]
                else:
                    if g not in dico_size[(y,x)]:
                        dico_size[(y,x)] += [g]
        for data in list_traj:
            #data
            y1,x1,y2,x2,m1,m2,g= data           
            #get color
            cm_object = cm.Paired(1.*g/g_max)
            rgb = cm_object[:3]
            hexa = colors.rgb2hex(rgb)
            #trajectory
            #avoid when trajectory have the same start/end location
            #it's happened when subdivision are not found and the level is "town" location level
            if (y1,x1) != (y2,x2):
                for key in (y1,x1), (y2,x2):
                    sorted_g = sorted(dico_size[(key)])
                    size = (sorted_g.index(g) + 1) * 10
                    folium.PolyLine([key,key], color=hexa, weight=size, opacity=0.9).add_to(my_map)
                folium.PolyLine([(y1,x1),(y2,x2)], popup=popup_trajectory[(m1,m2)].decode('iso8859_15') , color=hexa, weight=nb_polyline[(y1,x1),(y2,x2)]*5, opacity=0.9).add_to(my_map)
                nb_polyline[(y1,x1),(y2,x2)] -= 1
            else:
                sorted_g = sorted(dico_size[(y1,x1)])
                size = (sorted_g.index(g) + 1) * 10
                folium.PolyLine([(y1,x1),(y1,x1)], color=hexa, weight=size, opacity=0.9).add_to(my_map)
            #marker
            if (y1,x1) not in town_set:
                folium.Marker([y1, x1], popup=' '.join(list(dico_pop[(y1,x1)]))).add_to(my_map)
                town_set.add((y1,x1))
            if (y2,x2) not in town_set:
                folium.Marker([y2, x2], popup=' '.join(list(dico_pop[(y2,x2)]))).add_to(my_map)
                town_set.add((y2, x2))
        for key, (text, y, x) in dico_annotation.items():
            if (y,x) not in town_set:
                icon = folium.Icon(color=u'black')
                town_set.add(key)
                try:
                    folium.Marker([y,x], popup=key.decode('iso8859_15')+"\n"+text.decode('iso8859_15'), icon=icon).add_to(my_map)
                except UnicodeEncodeError:
                    folium.Marker([y,x], popup=key+"\n"+text, icon=icon).add_to(my_map)
                
                
                
    filename1 = filename.replace(' ','_').replace('.ged','')+'_map_'+str(typ)+'_1.html'
    filename2 = filename.replace(' ','_').replace('.ged','')+'_map_'+str(typ)+'_2.html'
    my_map1.save(filename1)
    my_map2.save(filename2)
    webbrowser.open(filename1)
    webbrowser.open(filename2)

def generate_map(typ,y_min, x_min, y_max, x_max,g_max,list_traj,dico_annotation):
    """
    Generate Open Street Map HTML page
    """
    xmean = np.mean([x_min,x_max])
    ymean = np.mean([y_min,y_max])
    if typ == 1:
        list_traj = sorted(list_traj, key=itemgetter(6), reverse=True)
    elif typ == 2:
        list_traj = sorted(list_traj, key=itemgetter(6), reverse=True)
    my_map = folium.Map(location=[ymean,xmean],tiles='Stamen Terrain',zoom_start=6)
    town_set = set()
    dico_traj_size = dict()
    for data in list_traj:
        #data
        y1,x1,y2,x2,m1,m2,g= data
        #get color
        cm_object = cm.Paired(1.*g/g_max)
        rgb = cm_object[:3]
        hexa = colors.rgb2hex(rgb)
        #trajectory
        folium.PolyLine([(y1,x1),(y2,x2)], color=hexa, weight=g, opacity=1).add_to(my_map)
        
        #marker
        if m1 not in town_set:
            folium.Marker([y1, x1], popup=m1+"\n"+dico_annotation[m1.encode('iso8859_15')][0]).add_to(my_map)
            town_set.add(m1)
        if m2 not in town_set:
            folium.Marker([y2, x2], popup=m2+"\n"+dico_annotation[m2.encode('iso8859_15')][0]).add_to(my_map)
            town_set.add(m2)
    for key in dico_annotation.keys():
        if key.decode('iso8859_15') not in town_set:
            pass
            #folium.Marker([dico_annotation[m2.encode('iso8859_15')][1], dico_annotation[m2.encode('iso8859_15')][2]], popup=key+"\n"+dico_annotation[m2.encode('iso8859_15')][0]; color="black").add_to(my_map)
    filename = 'map_'+str(typ)+'.html'
    my_map.save(filename)
    webbrowser.open(filename)
    
######
# TEST #
######
"""
Variable for Demo and caught the data for further analysis
"""

ascdt = None
town_list = None
dico_annotation =None
list_traj = None
list_coord = None
y_min = None
x_min = None
y_max = None
x_max = None
g_max = None
fig = None
m = None
ax = None
points_with_annotation = None

def Demo_ascdt():
    """
    Create the map with all the options, the example ascendance file and the town file
    """
    fa = "Fichier ascendance.txt"
    t = "Fichier lieux total.csv"
    options =  ['Nombre de °,x,+',"Nombre total d'événement",'Départ(s)','Arrivée(s)','Nom(s)', 'Dates extrêmes']
    typ = 1
    #import ascendance
    global ascdt, town_list, dico_annotation, list_traj, list_coord, y_min, x_min, y_max, x_max, g_max, fig, m, ax, points_with_annotation
    ascdt = import_ascendance(fa)
    #import the town file
    town_list = import_town_gps_coord(t)
    #create annotation text
    dico_annotation = create_annotation_text(ascdt,town_list,options,typ)
    #compute the trajectory
    list_traj, list_coord = convert_to_trajectory_ascdt(ascdt,town_list)
    #find the min and max coordinate
    y_min, x_min, y_max, x_max, g_max = find_min_max_coordinate(list_coord)
    #generate the OpenStreetMap
    generate_map(typ,y_min, x_min, y_max, x_max,g_max,list_traj,dico_annotation)
    #mapping the map
    print("mapping the map")
    fig, m, ax = carte(y_min, x_min, y_max, x_max)
    #mapping the trajectories (no return variable)
    print("mapping the trajectories")
    points_with_annotation, list_text_point = mapping_trajectory(list_traj,m,ax, g_max,typ,dico_annotation)

    def on_move(event):
        """
        show dynamical annotation when the mouse pass over the point
            1- get the current axis extremity coordinate and divide them by 20
            2- get the looked point position and the position of his annotation
            3- add the 1/20e of the scale lenght of the curent figure to the xytext coordinate annotation
            4- check all the points if they are outer of the figure and set the text not visible
        """
        #get tuple of limit axis during the time
        x_lim = ax.get_xlim()
        y_lim = ax.get_ylim()
        x = x_lim[0]
        y = y_lim[0]
        x2 = x_lim[1]
        y2 = y_lim[1]
        x10 = (x2-x)/20.
        y10 = (y2-y)/20.
        
        for text in list_text_point:
            x_txt, y_txt = text.get_position()
            
            if x <= x_txt <= x2 and y <= y_txt <= y2:
                text.set_visible(True)
            else:
                text.set_visible(False)
            plt.draw()

        visibility_changed = False
        
        for point, annotation in points_with_annotation:
            #get position of the point
            p_xy = point.get_xydata()
            p_x = p_xy[0][0]
            p_y = p_xy[0][1]
            #and set the anotation with add 1/10 of y and x spaces
            annotation.set_position((p_x+x10,p_y+y10))
            
            should_be_visible = (point.contains(event)[0] == True)

            if should_be_visible != annotation.get_visible():
                visibility_changed = True
                
                annotation.set_visible(should_be_visible)

        if visibility_changed:        
            plt.draw()
    
    on_move_id = fig.canvas.mpl_connect('motion_notify_event', on_move)
    plt.show()

def Demo_descdt():
    """
    Create the map with all the options, the example descendance file and the town file
    """
    fd = "pelissier_5g_nys_descendance.txt"
    t = "Fichier lieux total.csv"
    options =  ['Nombre de °,x,+',"Nombre total d'événement",'Départ(s)','Arrivée(s)','Nom(s)', 'Dates extrêmes']
    typ = 2
    #import ascendance
    global ascdt, town_list, dico_annotation, list_traj, list_coord, y_min, x_min, y_max, x_max, g_max, fig, m, ax, points_with_annotation
    descdt = import_descendance(fd)
    #import the town file
    town_list = import_town_gps_coord(t)
    #create annotation text
    dico_annotation = create_annotation_text(descdt,town_list,options,typ)
    #compute the trajectory
    list_traj, list_coord = convert_to_trajectory_descdt(descdt,town_list)
    #find the min and max coordinate
    y_min, x_min, y_max, x_max, g_max = find_min_max_coordinate(list_coord)
    #generate the OpenStreetMap
    generate_map(typ,y_min, x_min, y_max, x_max,g_max,list_traj,dico_annotation)
    #mapping the map
    print("mapping the map")
    fig, m, ax = carte(x_min, y_min, x_max, y_max)
    #mapping the trajectories (no return variable)
    print("mapping the trajectories")
    points_with_annotation, list_text_point = mapping_trajectory(list_traj,m,ax, g_max,typ,dico_annotation)

    def on_move(event):
        """
        show dynamical annotation when the mouse pass over the point
            1- get the current axis extremity coordinate and divide them by 20
            2- get the looked point position and the position of his annotation
            3- add the 1/20e of the scale lenght of the curent figure to the xytext coordinate annotation
            4- check all the points if they are outer of the figure and set the text not visible
        """
        #get tuple of limit axis during the time
        x_lim = ax.get_xlim()
        y_lim = ax.get_ylim()
        x = x_lim[0]
        y = y_lim[0]
        x2 = x_lim[1]
        y2 = y_lim[1]
        x10 = (x2-x)/20.
        y10 = (y2-y)/20.
        
        for text in list_text_point:
            x_txt, y_txt = text.get_position()
            
            if x <= x_txt <= x2 and y <= y_txt <= y2:
                text.set_visible(True)
            else:
                text.set_visible(False)
            plt.draw()

        visibility_changed = False
        
        for point, annotation in points_with_annotation:
            #get position of the point
            p_xy = point.get_xydata()
            p_x = p_xy[0][0]
            p_y = p_xy[0][1]
            #and set the anotation with add 1/10 of y and x spaces
            annotation.set_position((p_x+x10,p_y+y10))
            
            should_be_visible = (point.contains(event)[0] == True)

            if should_be_visible != annotation.get_visible():
                visibility_changed = True
                
                annotation.set_visible(should_be_visible)

        if visibility_changed:        
            plt.draw()
    
    on_move_id = fig.canvas.mpl_connect('motion_notify_event', on_move)
    plt.show()
