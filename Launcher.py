#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
(c) Copyright Yoan BOUZIN

  This file is part of Pérégrination v1.0.

    Pérégrination v1.0 is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Pérégrination v1.0 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Pérégrination v1.0.  If not, see <http://www.gnu.org/licenses/>. 2
"""

###########
# IMPORTS #
###########

from peregrination import *
import Tkinter
import tkFileDialog
import tkMessageBox

######
# GUI #
######


class Peregrination():
    #principal application
    def __init__(self):
        """
        initialize the GUI
        """
        #check platform
        from sys import platform
        if platform == "linux" or platform == "linux2":
            font = "URW Chancery L"
        elif platform == "darwin":
            font = "URW Chancery L"
        elif platform == "win32":
            font = "Segoe Script"
        self.main = Tkinter.Tk()
        self.main.title("Pérégrination v1.5")
        #self.main.geometry("176x145")
        #self.main.resizable(width=False, height=False)
        self.main.configure(bg="#a0522d")
        self.label1 = Tkinter.Label(self.main,text="Pérégrination v 1.0", font=(font, 12), bg="#f5deb3")
        self.label1.grid(sticky='EW', padx=10, pady=5)
        self.bouton1 = Tkinter.Button(master=self.main,text="Charger le fichier d'ascendance", command=self.load_ascdt_txt,bg="#f5deb3")
        self.bouton1.grid(sticky='EW')
        self.bouton2 = Tkinter.Button(master=self.main,text="Charger le fichier de descendance", command=self.load_descdt_txt,bg="#f5deb3")
        self.bouton2.grid(sticky='EW')
        self.bouton3 = Tkinter.Button(master=self.main,text="Charger le fichier de lieux", command=self.load_csv,bg="#f5deb3")
        self.bouton3.grid(sticky='NSEW')
        self.bouton4 = Tkinter.Button(master=self.main,text="Options d'affichage", command=self.options,bg="#f5deb3")
        self.bouton4.grid(sticky='NSEW')
        self.bouton5 = Tkinter.Button(master=self.main,text="Créé la carte", command=self.mapping,bg="#f5deb3")
        self.bouton5.grid(sticky='NSEW')
        self.bouton6 = Tkinter.Button(master=self.main,text="Quitter",command=self.main.destroy,bg="#f5deb3")
        self.bouton6.grid(sticky='NSEW')
        self.label1 = Tkinter.Label(self.main,text="© Yoan BOUZIN - Licence GNU", font=(font, 12), bg="#f5deb3")
        self.label1.grid(sticky='EW', padx=10, pady=5)

        ##########
        # VARIABLES #
        ##########
        
        self.fichier_ascendance = None
        self.fichier_descendance = None
        self.fichier_lieux = None
        self.choosen_options = list()
        
    def run(self):
        """
        function to keep the GUI in live
        """
        self.center(self.main)
        self.main.mainloop()
    def center(self,toplevel):
        """
        To center a Tkinter TopLevel() window
        """
        toplevel.update_idletasks()
        w = toplevel.winfo_screenwidth()
        h = toplevel.winfo_screenheight()
        size = tuple(int(_) for _ in toplevel.geometry().split('+')[0].split('x'))
        x = w/2 - size[0]/2
        y = h/2 - size[1]/2
        toplevel.geometry("%dx%d+%d+%d" % (size + (x, y)))
    def load_ascdt_txt(self):
        """
        Saving the ascendance file generated by Heredis (see the User Manual) in the variable self.fichier_ascendance variable
        """
        self.bouton2.config(state="disabled")
        self.fichier_ascendance = tkFileDialog.askopenfilename(title="Ouvrir le fichier d'ascendance:", initialdir=os.getcwd(), \
                                initialfile="", filetypes = [("Fichiers txt","*.txt"),("Tous", "*")])
        if not self.fichier_ascendance:
            self.bouton2.config(state="active")
        self.type = 1
    def load_descdt_txt(self):
        """
        Saving the descendance file generated by Heredis (see the UserManuel) in the variable self.fichier_descendance
        """
        self.bouton1.config(state="disabled")
        self.fichier_descendance = tkFileDialog.askopenfilename(title="Ouvrir le fichier de descendance:", initialdir=os.getcwd(), \
                                initialfile="", filetypes = [("Fichiers txt","*.txt"),("Tous", "*")])
        if not self.fichier_descendance:
            self.bouton1.config(state="active")
        self.type = 2
    def load_csv(self):
        """
        Saving the town file generated by SQLite Manager (Firefox, see the UserManual) in the variable self.fichier_descendance
        """
        self.fichier_lieux = tkFileDialog.askopenfilename(title="Ouvrir le fichier CSV des Lieux:", initialdir=os.getcwd(), \
                                initialfile="", filetypes = [("Fichiers CSV","*.csv"),("Tous", "*")])
    def options(self):
        """
        Create Tkinter TopLevel() windows to show the option can be checked by the user
        Actual option are :
            - Nombre de °,x,+
            - Nombre total d'événement
            - Départ(s)
            - Arrivée(s)
            - Nom(s)
            - Dates extrêmes
        """
        self.liste_checkbox = list()
        #make the new window
        self.option = Tkinter.Toplevel()
        self.center(self.option)
        self.option.title("Options :")
        self.option.configure(bg="#f5deb3")
        self.option_list = ['Nombre de °,x,+',"Nombre total d'événement",'Départ(s)','Arrivée(s)','Nom(s)', 'Dates extrêmes']
        for text in self.option_list :
            var = Tkinter.IntVar()
            self.liste_checkbox += [var]
            c = Tkinter.Checkbutton(self.option, text=text, variable=var,bg="#f5deb3")
            c.grid()
        self.validate_button = Tkinter.Button(self.option,text="Valider",command=self.option_command,bg="#a0522d", fg="#f5deb3", font=('Sans','10','bold'))
        self.validate_button.grid()

    def option_command(self):
        """
        Saving the option choosen by the user in the List self.choosen_options
        """
        for i in range(len(self.option_list)):
            option = self.liste_checkbox[i].get()
            if option:
                self.choosen_options += [self.option_list[i]]
        self.option.destroy()


    def mapping(self):
        """
        Generate the map
        """
        if not self.fichier_lieux or self.type == None:
            tkMessageBox.showwarning(message="Vous n'avez pas charger de fichier d'ascendance / descendance ou de fichier de lieux")
            return
        else:
            if len(self.choosen_options) == 0:
                self.choosen_options = ['Départ(s)','Arrivée(s)']
            if self.type == 1:
                print("import the ascendance file")
                #import ascendance
                ascdt = import_ascendance(self.fichier_ascendance)
                #import the town file
                town_list = import_town_gps_coord(self.fichier_lieux)
                #create annotation text
                dico_annotation = create_annotation_text(ascdt,town_list,self.choosen_options,self.type)
                #compute the trajectory
                list_traj, list_coord = convert_to_trajectory_ascdt(ascdt,town_list)
                #find the min and max coordinate
                y_min, x_min, y_max, x_max, g_max = find_min_max_coordinate(list_coord)
                #generate the OpenStreetMap
                generate_map(self.type,y_min, x_min, y_max, x_max,g_max,list_traj,dico_annotation)
                #mapping the map
                print("mapping the map")
                fig, m, ax = carte(y_min, x_min, y_max, x_max)
                #mapping the trajectories (no return variable)
                print("mapping the trajectories")
                points_with_annotation, list_text_point = mapping_trajectory(list_traj,m,ax, g_max,self.type,dico_annotation)
                
            if self.type == 2:
                print("import the descendance file")
                #import descendance
                descdt = import_descendance(self.fichier_descendance)
                #import the town file
                town_list = import_town_gps_coord(self.fichier_lieux)
                #create annotation text
                dico_annotation = create_annotation_text(descdt,town_list,self.choosen_options,self.type)
                #compute the trajectory *** !!! ***
                list_traj, list_coord = convert_to_trajectory_descdt(descdt,town_list)
                #find the min and max coordinate
                y_min, x_min, y_max, x_max, g_max = find_min_max_coordinate(list_coord)
                #generate the OpenStreetMap
                generate_map(self.type,y_min, x_min, y_max, x_max,g_max,list_traj,dico_annotation)
                #mapping the map
                print("mapping the map")
                fig, m, ax = carte(y_min, x_min, y_max, x_max)
                #mapping the trajectories (no return variable)
                print("Compute the trajectories")
                points_with_annotation, list_text_point = mapping_trajectory(list_traj,m,ax, g_max, self.type,dico_annotation)

        print('showing')

        def on_move(event):
            """
            show dynamical annotation when the mouse pass over the point
                1- get the current axis extremity coordinate and divide them by 20
                2- get the looked point position and the position of his annotation
                3- add the 1/20e of the scale lenght of the curent figure to the xytext coordinate annotation
                4- check all the points if they are outer of the figure and set the text not visible
            """
            #get tuple of limit axis during the time
            x_lim = ax.get_xlim()
            y_lim = ax.get_ylim()
            x = x_lim[0]
            y = y_lim[0]
            x2 = x_lim[1]
            y2 = y_lim[1]
            x10 = (x2-x)/20.
            y10 = (y2-y)/20.
            
            for text in list_text_point:
                x_txt, y_txt = text.get_position()
                
                if x <= x_txt <= x2 and y <= y_txt <= y2:
                    text.set_visible(True)
                else:
                    text.set_visible(False)
                plt.draw()

            visibility_changed = False
            
            for point, annotation in points_with_annotation:
                #get position of the point
                p_xy = point.get_xydata()
                p_x = p_xy[0][0]
                p_y = p_xy[0][1]
                #and set the anotation with add 1/10 of y and x spaces
                annotation.set_position((p_x+x10,p_y+y10))
                
                should_be_visible = (point.contains(event)[0] == True)

                if should_be_visible != annotation.get_visible():
                    visibility_changed = True
                    
                    annotation.set_visible(should_be_visible)

            if visibility_changed:        
                plt.draw()
            
        on_move_id = fig.canvas.mpl_connect('motion_notify_event', on_move)
        plt.show()
            
        self.bouton1.config(state="active")
        self.bouton2.config(state="active")
        self.fichier_descendance = None
        self.fichier_lieux = None
        self.type = None

############
# AUTORUN #
############

if __name__ == '__main__':
    app = Peregrination()
    app.run()
